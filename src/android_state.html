<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Android模块</title>
    <style type="text/css">
        p {
            text-indent: 2em
        }
    </style>
</head>
<body>
<!--一级title-->

<h3>Android方向模块</h3>
<ul>
    <li>基础</li>
    <li>ui</li>
    <li>性能优化</li>
    <li>框架与架构</li>
    <li>NDK</li>
    <li>前端混合开发</li>
    <li><a href="./avstudio/av_studio.html">音视频（2018.7.29）</a></li>

</ul>
<h3>Android编程技巧</h3>
<ul>

    <li><a href="https://blog.csdn.net/z82367825/article/details/78820559">Android-实现电话自动接听/电话自动挂断功能（2018.7.29）</a></li>
    <li><a href="https://www.jianshu.com/p/172dd8ddc998">Unity3D之AR女友简易快速制作方法（2018.7.29）</a></li>
    <li><a href="http://baijiahao.baidu.com/s?id=1586376937926938389&wfr=spider&for=pc">Android:ART虚拟机和Dalvik虚拟机区别（2018.8.1）</a>
        <P> Android
            从5.0开始默认使用ART虚拟机执行程序,抛弃了Dalvik虚拟机.加快了Android的运行效率,提高系统的流畅性
            原因是Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码, Dalvik虚拟机有一个解释器，用来执行dex字节码,
            Android从2.2开始,通过JIT（Just-In-Time）进行Dalvik虚拟机的优化,将使用频率较高的字节码翻译成机器码，
            就可以有效地提高Dalvik虚拟机的执行效率。但即使用采用了JIT，Dalvik虚拟机还是比不上ART虚拟机,因为Dalvik翻译工作是在程序运行时的,
            而ART在APK在安装时就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了。
            安装:

            Android系统通过PackageManagerService来安装APK，在安装的过程，PackageManagerService会通过另外一个类Installer的成员函数dexopt来对APK里面的dex字节码进行优化,对Dalvik虚拟机来说只进行dex字节码的优化,而ART虚拟机将dex字节码翻译成本地机器码,注意的是两种虚拟机不管事字节码的优化还是翻译成机器码都会生成一个后缀是odex文件,只不过ART的是一个oat类型文件,什么是oat文件(不清楚,好像是Linux的文件)

            启动:

            Android系统在启动的时候，会创建一个Zygote(受精卵,)进程,一切进程产生的一个进程。Zygote进程在启动的过程中会创建一个Dalvik虚拟机(或是ART虚拟机)。Zygote进程是通过复制自己来创建新的应用程序进程的,他会连同虚拟机一并复制可以大大提高系统的启动速度,就像单例一样,不用再为每个进程new一个，而且每个应用进程所需要的虚拟机也都是直接拿来就可以了.
        </P>
    </li>
    <li><a href="https://www.jianshu.com/p/b29a21a162ad">Dalvik虚拟机原理及Xposed hook原理（2018.8.1）</a></li>
    <li>
        <a href="https://www.cnblogs.com/graphics/p/5140385.html">onSingleTapUp()和onSingleTapConfirmed()的区别（2018.8.1）</a>

        <P>
            onSingleTapUp()和onSingleTapConfirmed()的区别
            onSingleTapUp() - 在按下并抬起时发生，只要符合这个条件就触发该函数，没有任何附加条件。

            onSingleTapConfirmed() 同上者，但有附加条件，就是Android会确保单击之后短时间内没有再次单击，才会触发该函数。

            举个列子，如果监听双击事件：onSingleTapUp()会被触发两次。但是onSingleTapConfirmed()一次都不会被触发。

            所以，如果你既想监听单击事件，又想监听双击时间，那么请使用onSingleTapConfirmed()函数。

        </P>

    </li>

    <li><a href="https://blog.csdn.net/rnzuozuo/article/details/77930543">作为一个安卓开发，如何去开发AR?需要具体学什么？（2018.8.2）</a>

        <P>如果已经有安卓开发的基础，只是开发一些应用层软件的话，只需要在安卓的原生开发框架上面整

            合第三方的AR SDK进来，并执行相应的三维动画效果。底层的算法，如：图像识别，多目标识

            别，动态识别，坐标定位等，SDK本身都已经提供了相应的算法支持，如果涉及到底层的软件研


            发，则需要了解很多算法的知识；如果只是应用层的开发，主要牵涉到两个领域的知识点：


            AR SDK的使用和整合；


            三维动画的制作；


            目前国外的AR SDK有高通的Vuforia和Metaio，不过Metaio已被苹果收购，不再提供软件服务支


            持，这两个平台发展时间较长，功能相对比较完善，但缺乏本地化的支持。国内目前了解到的有视


            辰的EasyAR和亮风台HiAR。


            Vuforia官网：https://developer.vuforia.com；


            EasyAR官网：http://www.easyar.cn;


            HiAR官网： https://www.hiscene.com；


            三维动画软件目前支持Unity3D,Maya,3DMAX等，归属于设计领域，一般并不是程序员去做。目前


            大多数AR SDK都支持Unity，建议使用Unity。


            Unity3D官网：Unity - Game Engine


            如果需要实现一些基础的算法绘图，可能需要用到opencv。


        </P>
    </li>
    <li>
        <a href="https://www.cnblogs.com/graphics/p/5140385.html">onSingleTapUp()和onSingleTapConfirmed()的区别（2018.8.1）</a>

        <P>
            onSingleTapUp()和onSingleTapConfirmed()的区别
            onSingleTapUp() - 在按下并抬起时发生，只要符合这个条件就触发该函数，没有任何附加条件。

            onSingleTapConfirmed() 同上者，但有附加条件，就是Android会确保单击之后短时间内没有再次单击，才会触发该函数。

            举个列子，如果监听双击事件：onSingleTapUp()会被触发两次。但是onSingleTapConfirmed()一次都不会被触发。

            所以，如果你既想监听单击事件，又想监听双击时间，那么请使用onSingleTapConfirmed()函数。

        </P>

    </li>

    <li><a>windowIsTranslucent（2018.8.2）</a>

        <P>

            <!--窗口半透明 慎用-->
            <!--<item name="android:windowIsTranslucent">true</item>-->


        </P>
    </li>

    <li><a href="https://blog.csdn.net/qq_15003505/article/details/51592431">Android使用SO库时要注意的一些问题（2018.8.6）</a>

        <P>

            <!--窗口半透明 慎用-->
            <!--<item name="android:windowIsTranslucent">true</item>-->


        </P>
    </li>
    <li><a href="https://blog.csdn.net/qwm8777411/article/details/45420451">Android常用实例—Alert Dialog的使用（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="https://github.com/lizixian18/EasyMvp">一个简单强大且灵活的MVP框架（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="https://github.com/fastZhang/AndPermission">权限管理库（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="http://www.cnblogs.com/yushiro/archive/2013/05/17/3084278.html">Unable to resume activity :
        android.database.StaleDataException: Attempted to access a cursor after it has been closed. 异常（2018.8.8）</a>

        <P>

        </P>
    </li>
    <li><a href="https://blog.csdn.net/saberhao/article/details/53909841">AndroidN适配的异常：java.lang.SecurityException: Not
        allowed to change Do
        Not Disturb state 异常（2018.8.9）</a>

        <P>

        </P>
    </li>

    <li><a>android沉浸式界面体验（2018.8.9）</a>

        <P>
            onCreate:
            ==========
            Window window = getWindow();
            WindowManager.LayoutParams params = window.getAttributes();
            params.systemUiVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY|
            View.SYSTEM_UI_FLAG_FULLSCREEN;
            window.setAttributes(params);

        </P>
    </li>

    <li><a href="https://blog.csdn.net/xx326664162/article/details/68490059/">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注（2018.8.14）</a>

        <P>
            4、Provided 和annotationProcessor区别
            annotationProcessor
            只在编译的时候执行依赖的库，但是库最终不打包到apk中，

            编译库中的代码没有直接使用的意义，也没有提供开放的api调用，最终的目的是得到编译库中生成的文件，供我们调用。

            Provided
            Provided 虽然也是编译时执行，最终不会打包到apk中，但是跟apt/annotationProcessor有着根本的不同。

            A 、B、C都是Library。
            A依赖了C，B也依赖了C
            App需要同时使用A和B
            那么其中A（或者B）可以修改与C的依赖关系为Provided

            A这个Library实际上还是要用到C的，只不过它知道B那里也有一个C，自己再带一个就显得多余了，等app开始运行的时候，A就可以通过B得到C，也就是两人公用这个C。所以自己就在和B汇合之前，假设自己有C。如果运行的时候没有C，肯定就要崩溃了。

            总结一下，Provided是间接的得到了依赖的Library，运行的时候必须要保证这个Library的存在，否则就会崩溃，起到了避免依赖重复资源的作用。

        </P>
    </li>
    <li><a href="https://blog.csdn.net/qq_29967217/article/details/56835467">androidstudio检测代码内的中文字符(解决安卓国际化修改字符问题)（2018.8.16）</a>

        <P>
            ^((?!(\*|//)).)+[\u4e00-\u9fa5]
        </P>
    </li>
    <li><a href="http://blog.sina.com.cn/s/blog_463559bc0101dhfa.html">NDK编译时NDK_MODULE_PATH定义问题
        import-module（2018.8.17）</a>


        <P>
            cocos2d-x 2.0以上版本需要设置NDK_MODULE_PATH环境变量，因为在android.mk文件里一般会有$(call
            import-module,***)来导入模块，导入时就是根据设置的NDK_MODULE_PATH来寻找目标模块的。下面说下我这半天时间总结出来的几种设置NDK_MODULE_PATH的方式：

            1、build_native.sh。

            项目自带的build_native.sh文件最后可以看到：

            if [[ "$buildexternalsfromsource" ]]; then
            echo "Building external dependencies from source"
            set -x
            "$NDK_ROOT"/ndk-build -C "$APP_ANDROID_ROOT" $* \
            "NDK_MODULE_PATH=${COCOS2DX_ROOT}:${COCOS2DX_ROOT}/cocos2dx/platform/third_party/android/source"
            else
            echo "Using prebuilt externals"
            set -x
            "$NDK_ROOT"/ndk-build -C "$APP_ANDROID_ROOT" $* \
            "NDK_MODULE_PATH=${COCOS2DX_ROOT}:${COCOS2DX_ROOT}/cocos2dx/platform/third_party/android/prebuilt"
            fi
            这里有设置NDK_MODULE_PATH。可以直接用cygwin运行这个批处理。


            2、eclipse

            添加ndk-build.cmd编译器时，可以添加NDK_MODULE_PATH的环境变量。这个网上很多资料，不讲了。


            在r7版本以后，NDK自带linux编译环境，不再需要cygwin，而我又不喜欢直接eclipse里加入NDK编译器然后一键编译这种比较呆比较臃肿的方式，所以我一般都是在NDK的build/core/build_local.mk里加入NDK_PROJECT_PATH
            = E:/cocos2d-2.0-x-2.0.4/samples/HelloCpp/proj.android，然后打开CMD，直接敲ndk-build编译。这时可以如3、4、5这样设置。


            3、android.mk

            在项目的android.mk的import_module之前添加导入模块的路劲。如：

            #$(call import-add-path, E:/cocos2d-2.0-x-2.0.4)
            #$(call import-add-path, E:/cocos2d-2.0-x-2.0.4/cocos2dx/platform/third_party/android/prebuilt)


            $(call import-module,cocos2dx)

            但这2个路径显然跟项目无关，加在这需要每个项目mk都加，显然不明智。所以见4。


            4、ndk-build.cmd

            在最后一句调用make.exe之前。加入

            set
            NDK_MODULE_PATH=E:/cocos2d-2.0-x-2.0.4;E:/cocos2d-2.0-x-2.0.4/cocos2dx/platform/third_party/android/prebuilt

            可以看到ndk-build.cmd会去读取build_local.mk，所以像上面说的设置NDK_PROJECT_PATH那样设置NDK_MODULE_PATH应该也是可以的，未验证，有兴趣可以去尝试一下。


            5、在cmd里敲ndk-build时，直接当成参数带在后面。可以看到1里面所说的build_native.sh里也是这样子传参进去的。未验证。

        </P>
    </li>
    <li><a href="http://ocnyang.com/">博客模版 import-module（2018.8.20）</a>


        <P>
            https://github.com/Huxpro/huxpro.github.io
            https://github.com/fastZhang/simple
            https://wordzzzz.github.io/2018/01/10/HEXO/

            https://github-laziji.github.io/#/user/social/main超牛

            Jekyll 、hexo、hugo

            Hexo， Hugo， Jekyll， Ghost

            https://www.jianshu.com/p/f1b02e00f206

            gist

            七牛云

        </P>
    </li>
    <li><a href="https://blog.csdn.net/wuxiaolongtongxue/article/details/53150829">手把手教你做个人 app（2018.8.22）</a>


        <P>
            手把手教你做个人 app

        </P>
    </li>
    <li><a href="http://wuxiaolong.me/2015/11/06/DesignSupportLibrary/">Android Design Support Library使用
        app（2018.8.22）</a>


        <P>
            手把手教你做个人 app

        </P>
    </li>
    <li><a href="https://blog.csdn.net/eclipsexys/article/details/51838119">Android Vector曲折的兼容之路
        app（2018.8.22）</a>


        <P>
            手把手教你做个人 app

        </P>
    </li>
    <li><a href="https://blog.csdn.net/tiankong1206/article/details/47057719">十个Android Material Design库
        （2018.8.23）</a>


        <P>
            手把手教你做个人 app

        </P>
    </li>
    </li>
    <li><a href="https://www.jianshu.com/p/8a66806588bc">Android各个版本新特性
        （2018.8.23）</a>
        https://developer.android.com/about/versions/pie/

        <P>
            Android各个版本新特性
            96 西门狂野
            2017.04.06 14:58* 字数 775 阅读 5199评论 2喜欢 19
            目前主流的Android适配版本最低版本4.0或5.0，这里主要总结一下Android 4.0以后各个版本特性，方便适配和面试。加粗标注为面试中问到的重点特性，其他为重要适配特性。（倒序）

            Android 8.0
            优化通知
            通知渠道
            通知标志
            休眠
            通知超时
            通知设置
            通知清除
            自动填充框架
            画中画模式：清单中Activity设置android:supportsPictureInPicture
            可下载字体：FontRequest
            XML 中的字体
            自动调整 TextView 的大小
            自适应图标
            颜色管理
            WebView API
            多显示器支持
            统一的布局外边距和内边距
            image.png
            指针捕获
            应用类别
            Android TV 启动器
            AnimatorSet
            新的 StrictMode 检测程序
            image.png
            缓存数据
            findViewById() 签名变更
            image.png
            权限
            image.png
            更新的 Java 支持
            image.png
            Android 7.1
            加入重启按钮
            App圆形图标
            添加新的Emoji
            Android 7.0
            电池和内存
            低电耗模式
            Project Svelte：后台优化
            权限更改
            系统权限更改
            在应用间文件共享权限控制
            多窗口支持
            通知栏快捷回复
            支持VR
            引入JIT编译器
            画中画
            App快捷菜单
            Android 6.0
            运行时请求权限
            低电耗模式和应用待机模式
            取消支持 Apache HTTP 客户端
            BoringSSL
            硬件标识符访问权
            通知
            音频管理器变更
            支持文本选择
            Android 密钥库不再支持 DSA。但仍支持 ECDSA
            WLAN 和网络连接变更
            相机服务变更
            APK 验证
            USB 连接
            Android 5.0
            Android Runtime (ART)默认运行平台设置
            通知
            - Material Design 样式
            - 声音和振动
            - 锁定屏幕可见性
            - 媒体播放
            - 浮动通知
            引入Material Design设计
            支持OpenGL ES3.1
            媒体控件和 RemoteControlClient
            getRecentTasks()
            支持Android NDK中的64位
            只能显示绑定到服务，取消隐藏绑定服务
            WebView API修改
            自定义权限唯一性要求
            TLS/SSL 默认配置变更
            - 服务器不支持任何已启用的加密套件
            - 应用对用于连接服务器的加密套件做出错误的假设
            - 服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展
            支持托管配置文件
            Android 4.4
            支持Android Beam
            添加打印框架
            存储访问框架
            低功耗传感器
            添加短信提供程序
            添加全屏沉浸模式
            Android 沉浸式状态栏的三种实现方式
            兼容库SystemBarTint
            添加透明系统 UI 样式
            添加新的媒体功能
            RenderScript Compute
            持续性能提升
            GPU 加速
            Android NDK 中的 RenderScript
            图形
            GLES2.0 SurfaceFlinge
            新的硬件合成器支持虚拟显示
            支持新的连接类型
            新的蓝牙配置文件
            红外发射器
            Wi-Fi TDLS 支持
            无障碍功能
            安全增强功能
            内存使用率分析工具
            Procstats
            Android 4.0,4.1,4.2,4.3
            支持OpenGL ES 3.0
            增强蓝牙连接
            优化位置和传感器
            添加转场动画
            支持Daydream
            人脸识别解锁
            Photo Sphere 全景相片
            小礼物走一走，来简书关注我


        </P>
    </li>


</ul>


</body>
</html>