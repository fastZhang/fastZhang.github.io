<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Android模块</title>
    <style type="text/css">
        p {
            text-indent: 2em
        }
    </style>
</head>
<body>
<!--一级title-->

<h3>Android方向模块</h3>
<ul>
    <li>基础</li>
    <li>ui</li>
    <li>性能优化</li>
    <li>框架与架构</li>
    <li>NDK</li>
    <li>前端混合开发</li>
    <li><a href="./avstudio/av_studio.html">音视频（2018.7.29）</a></li>

</ul>
<h3>Android编程技巧</h3>
<ul>

    <li><a href="https://blog.csdn.net/z82367825/article/details/78820559">Android-实现电话自动接听/电话自动挂断功能（2018.7.29）</a></li>
    <li><a href="https://www.jianshu.com/p/172dd8ddc998">Unity3D之AR女友简易快速制作方法（2018.7.29）</a></li>
    <li><a href="http://baijiahao.baidu.com/s?id=1586376937926938389&wfr=spider&for=pc">Android:ART虚拟机和Dalvik虚拟机区别（2018.8.1）</a>
        <P> Android
            从5.0开始默认使用ART虚拟机执行程序,抛弃了Dalvik虚拟机.加快了Android的运行效率,提高系统的流畅性
            原因是Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码, Dalvik虚拟机有一个解释器，用来执行dex字节码,
            Android从2.2开始,通过JIT（Just-In-Time）进行Dalvik虚拟机的优化,将使用频率较高的字节码翻译成机器码，
            就可以有效地提高Dalvik虚拟机的执行效率。但即使用采用了JIT，Dalvik虚拟机还是比不上ART虚拟机,因为Dalvik翻译工作是在程序运行时的,
            而ART在APK在安装时就对其包含的Dex字节码进行翻译，得到对应的本地机器指令，于是就可以在运行时直接执行了。
            安装:

            Android系统通过PackageManagerService来安装APK，在安装的过程，PackageManagerService会通过另外一个类Installer的成员函数dexopt来对APK里面的dex字节码进行优化,对Dalvik虚拟机来说只进行dex字节码的优化,而ART虚拟机将dex字节码翻译成本地机器码,注意的是两种虚拟机不管事字节码的优化还是翻译成机器码都会生成一个后缀是odex文件,只不过ART的是一个oat类型文件,什么是oat文件(不清楚,好像是Linux的文件)

            启动:

            Android系统在启动的时候，会创建一个Zygote(受精卵,)进程,一切进程产生的一个进程。Zygote进程在启动的过程中会创建一个Dalvik虚拟机(或是ART虚拟机)。Zygote进程是通过复制自己来创建新的应用程序进程的,他会连同虚拟机一并复制可以大大提高系统的启动速度,就像单例一样,不用再为每个进程new一个，而且每个应用进程所需要的虚拟机也都是直接拿来就可以了.
        </P>
    </li>
    <li><a href="https://www.jianshu.com/p/b29a21a162ad">Dalvik虚拟机原理及Xposed hook原理（2018.8.1）</a></li>
    <li>
        <a href="https://www.cnblogs.com/graphics/p/5140385.html">onSingleTapUp()和onSingleTapConfirmed()的区别（2018.8.1）</a>

        <P>
            onSingleTapUp()和onSingleTapConfirmed()的区别
            onSingleTapUp() - 在按下并抬起时发生，只要符合这个条件就触发该函数，没有任何附加条件。

            onSingleTapConfirmed() 同上者，但有附加条件，就是Android会确保单击之后短时间内没有再次单击，才会触发该函数。

            举个列子，如果监听双击事件：onSingleTapUp()会被触发两次。但是onSingleTapConfirmed()一次都不会被触发。

            所以，如果你既想监听单击事件，又想监听双击时间，那么请使用onSingleTapConfirmed()函数。

        </P>

    </li>

    <li><a href="https://blog.csdn.net/rnzuozuo/article/details/77930543">作为一个安卓开发，如何去开发AR?需要具体学什么？（2018.8.2）</a>

        <P>如果已经有安卓开发的基础，只是开发一些应用层软件的话，只需要在安卓的原生开发框架上面整

            合第三方的AR SDK进来，并执行相应的三维动画效果。底层的算法，如：图像识别，多目标识

            别，动态识别，坐标定位等，SDK本身都已经提供了相应的算法支持，如果涉及到底层的软件研


            发，则需要了解很多算法的知识；如果只是应用层的开发，主要牵涉到两个领域的知识点：


            AR SDK的使用和整合；


            三维动画的制作；


            目前国外的AR SDK有高通的Vuforia和Metaio，不过Metaio已被苹果收购，不再提供软件服务支


            持，这两个平台发展时间较长，功能相对比较完善，但缺乏本地化的支持。国内目前了解到的有视


            辰的EasyAR和亮风台HiAR。


            Vuforia官网：https://developer.vuforia.com；


            EasyAR官网：http://www.easyar.cn;


            HiAR官网： https://www.hiscene.com；


            三维动画软件目前支持Unity3D,Maya,3DMAX等，归属于设计领域，一般并不是程序员去做。目前


            大多数AR SDK都支持Unity，建议使用Unity。


            Unity3D官网：Unity - Game Engine


            如果需要实现一些基础的算法绘图，可能需要用到opencv。


        </P>
    </li>
    <li>
        <a href="https://www.cnblogs.com/graphics/p/5140385.html">onSingleTapUp()和onSingleTapConfirmed()的区别（2018.8.1）</a>

        <P>
            onSingleTapUp()和onSingleTapConfirmed()的区别
            onSingleTapUp() - 在按下并抬起时发生，只要符合这个条件就触发该函数，没有任何附加条件。

            onSingleTapConfirmed() 同上者，但有附加条件，就是Android会确保单击之后短时间内没有再次单击，才会触发该函数。

            举个列子，如果监听双击事件：onSingleTapUp()会被触发两次。但是onSingleTapConfirmed()一次都不会被触发。

            所以，如果你既想监听单击事件，又想监听双击时间，那么请使用onSingleTapConfirmed()函数。

        </P>

    </li>

    <li><a>windowIsTranslucent（2018.8.2）</a>

        <P>

            <!--窗口半透明 慎用-->
            <!--<item name="android:windowIsTranslucent">true</item>-->


        </P>
    </li>

    <li><a href="https://blog.csdn.net/qq_15003505/article/details/51592431">Android使用SO库时要注意的一些问题（2018.8.6）</a>

        <P>

            <!--窗口半透明 慎用-->
            <!--<item name="android:windowIsTranslucent">true</item>-->


        </P>
    </li>
    <li><a href="https://blog.csdn.net/qwm8777411/article/details/45420451">Android常用实例—Alert Dialog的使用（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="https://github.com/lizixian18/EasyMvp">一个简单强大且灵活的MVP框架（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="https://github.com/fastZhang/AndPermission">权限管理库（2018.8.7）</a>

        <P>

        </P>
    </li>
    <li><a href="http://www.cnblogs.com/yushiro/archive/2013/05/17/3084278.html">Unable to resume activity :
        android.database.StaleDataException: Attempted to access a cursor after it has been closed. 异常（2018.8.8）</a>

        <P>

        </P>
    </li>
    <li><a href="https://blog.csdn.net/saberhao/article/details/53909841">AndroidN适配的异常：java.lang.SecurityException: Not
        allowed to change Do
        Not Disturb state 异常（2018.8.9）</a>

        <P>

        </P>
    </li>

    <li><a>android沉浸式界面体验（2018.8.9）</a>

        <P>
            onCreate:
            ==========
            Window window = getWindow();
            WindowManager.LayoutParams params = window.getAttributes();
            params.systemUiVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY|
            View.SYSTEM_UI_FLAG_FULLSCREEN;
            window.setAttributes(params);

        </P>
    </li>

    <li><a href="https://blog.csdn.net/xx326664162/article/details/68490059/">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注（2018.8.14）</a>

        <P>
            4、Provided 和annotationProcessor区别
            annotationProcessor
            只在编译的时候执行依赖的库，但是库最终不打包到apk中，

            编译库中的代码没有直接使用的意义，也没有提供开放的api调用，最终的目的是得到编译库中生成的文件，供我们调用。

            Provided
            Provided 虽然也是编译时执行，最终不会打包到apk中，但是跟apt/annotationProcessor有着根本的不同。

            A 、B、C都是Library。
            A依赖了C，B也依赖了C
            App需要同时使用A和B
            那么其中A（或者B）可以修改与C的依赖关系为Provided

            A这个Library实际上还是要用到C的，只不过它知道B那里也有一个C，自己再带一个就显得多余了，等app开始运行的时候，A就可以通过B得到C，也就是两人公用这个C。所以自己就在和B汇合之前，假设自己有C。如果运行的时候没有C，肯定就要崩溃了。

            总结一下，Provided是间接的得到了依赖的Library，运行的时候必须要保证这个Library的存在，否则就会崩溃，起到了避免依赖重复资源的作用。

        </P>
    </li>
    <li><a href="https://blog.csdn.net/qq_29967217/article/details/56835467">androidstudio检测代码内的中文字符(解决安卓国际化修改字符问题)（2018.8.16）</a>

        <P>
            ^((?!(\*|//)).)+[\u4e00-\u9fa5]
        </P>
    </li>
    <li><a href="http://blog.sina.com.cn/s/blog_463559bc0101dhfa.html">NDK编译时NDK_MODULE_PATH定义问题
        import-module（2018.8.17）</a>


        <P>
            cocos2d-x 2.0以上版本需要设置NDK_MODULE_PATH环境变量，因为在android.mk文件里一般会有$(call
            import-module,***)来导入模块，导入时就是根据设置的NDK_MODULE_PATH来寻找目标模块的。下面说下我这半天时间总结出来的几种设置NDK_MODULE_PATH的方式：

            1、build_native.sh。

            项目自带的build_native.sh文件最后可以看到：

            if [[ "$buildexternalsfromsource" ]]; then
            echo "Building external dependencies from source"
            set -x
            "$NDK_ROOT"/ndk-build -C "$APP_ANDROID_ROOT" $* \
            "NDK_MODULE_PATH=${COCOS2DX_ROOT}:${COCOS2DX_ROOT}/cocos2dx/platform/third_party/android/source"
            else
            echo "Using prebuilt externals"
            set -x
            "$NDK_ROOT"/ndk-build -C "$APP_ANDROID_ROOT" $* \
            "NDK_MODULE_PATH=${COCOS2DX_ROOT}:${COCOS2DX_ROOT}/cocos2dx/platform/third_party/android/prebuilt"
            fi
            这里有设置NDK_MODULE_PATH。可以直接用cygwin运行这个批处理。


            2、eclipse

            添加ndk-build.cmd编译器时，可以添加NDK_MODULE_PATH的环境变量。这个网上很多资料，不讲了。


            在r7版本以后，NDK自带linux编译环境，不再需要cygwin，而我又不喜欢直接eclipse里加入NDK编译器然后一键编译这种比较呆比较臃肿的方式，所以我一般都是在NDK的build/core/build_local.mk里加入NDK_PROJECT_PATH
            = E:/cocos2d-2.0-x-2.0.4/samples/HelloCpp/proj.android，然后打开CMD，直接敲ndk-build编译。这时可以如3、4、5这样设置。


            3、android.mk

            在项目的android.mk的import_module之前添加导入模块的路劲。如：

            #$(call import-add-path, E:/cocos2d-2.0-x-2.0.4)
            #$(call import-add-path, E:/cocos2d-2.0-x-2.0.4/cocos2dx/platform/third_party/android/prebuilt)


            $(call import-module,cocos2dx)

            但这2个路径显然跟项目无关，加在这需要每个项目mk都加，显然不明智。所以见4。


            4、ndk-build.cmd

            在最后一句调用make.exe之前。加入

            set
            NDK_MODULE_PATH=E:/cocos2d-2.0-x-2.0.4;E:/cocos2d-2.0-x-2.0.4/cocos2dx/platform/third_party/android/prebuilt

            可以看到ndk-build.cmd会去读取build_local.mk，所以像上面说的设置NDK_PROJECT_PATH那样设置NDK_MODULE_PATH应该也是可以的，未验证，有兴趣可以去尝试一下。


            5、在cmd里敲ndk-build时，直接当成参数带在后面。可以看到1里面所说的build_native.sh里也是这样子传参进去的。未验证。

        </P>
    </li>


</ul>


</body>
</html>